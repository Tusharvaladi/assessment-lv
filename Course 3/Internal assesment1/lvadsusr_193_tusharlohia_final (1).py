# -*- coding: utf-8 -*-
"""LVADSUSR_193_tusharlohia_final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ut2Hi2tc4eax1meuoOUlkNDylaW0WaNS

Q1. a
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv('/content/Final Dataset - IPL.csv')
df

"""Q1.b"""

df.info()

"""Q2 a"""

missing_data = df.isnull().sum()
print(missing_data)

#as there are no missing values then we dont have to fill anything on our own

"""Q2 b"""

dup_rows = df[df.duplicated()]
print(f"No. of duplicate rows: {len(dup_rows)}")

#there are no duplicate values therefore now we can start our analysis

"""Q3"""

def stats(data):

  mean = np.mean(data)
  mode = data.mode()[0]
  median = np.median(data)
  std_dev = np.std(data)
  range = np.max(data) - np.min(data)
  variance = np.var(data)

  return {
    "mean": mean,
    "mode": mode,
    "median": median,
    "standard deviation": std_dev,
    "range": range,
    "variance": variance
  }

stats(first_ings_score)

# using above function we can find the statistical data for any numeric value.
# mean, median, and mode are all measures of central tendency.
# The standard deviation, range, and variance tell us how spread out the data is.

"""Q4"""

df['first_ings_wkts'].plot(kind='hist', bins=20, title='first_ings_wkts')
plt.gca().spines[['top', 'right',]].set_visible(False)

# Mostly first innings gets over with bowling team getting 6 wickets

"""Q5"""

#how many times toss_winner and match_winner are same and how many times they arent same.

grouped_data = df.groupby('toss_match_winner').size()
plt.figure(figsize=(8, 6))
plt.bar(labels, values, color=['g', 'r'])
plt.xlabel('Toss Winner and Match Winner Comparison')
plt.ylabel('Count')
plt.title('Comparison of Toss Winner and Match Winner')
plt.show()

#toss decisions dont make a huge impact on winner as we can see in the graph below

"""Q6"""

plt.figure(figsize=(6, 6))
plt.scatter(df['first_ings_score'], df['match_id'])
plt.title('Scatter Plot of First Innings Score')
plt.xlabel('First Innings Score')
plt.ylabel('match_id')

plt.show()

# yes there are some outliers for example in the first_ings_score is greter than 130 in most of teh cases but there are some instances where it is less than 130.
# and we are keeping those outliers because it tells us that whenever there is a low score than 130 its always in the second half of tournament

"""Q7"""

venue_winner_counts.plot(kind='bar', stacked=False)
plt.xlabel('Venue')
plt.ylabel('Number of Matches Won')
plt.title('Match Winner Performance by Venue')
plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
plt.show()

# number of matches won by a team in a particular stadium

"""Q8"""

player_of_match_counts = df['player_of_the_match'].value_counts()
player_of_match_counts = player_of_match_counts.head(10)
plt.figure(figsize=(12, 6))
player_of_match_counts.plot(kind='bar')


plt.xlabel('Player')
plt.ylabel('Count')
plt.title('Count of Players as Player of the Match')
plt.xticks(rotation=90)
plt.tight_layout()
plt.show()

#kuldeep yadav won "player of the match" most number of times

"""Q9"""

#  Findings
#  there are 756 matches played in total
#  the average score is 158.43 with a standard deviation of 23.16
#  the highest score is 263 and the lowest score is 70
#  the average runs conceded is 159.86 with a standard deviation of 23.28
#  the highest runs conceded is 250 and the lowest runs conceded is 77


#  Insights
#  there is a high degree of variability in the scores and runs conceded in ipl matches
#  the average score and runs made are relatively close, indicating that matches are generally competitive
#  there have been some high-scoring matches with scores exceeding 250
#  there have also been some low-scoring matches with scores below 100


#  Outcomes
#  the data can be used to identify trends and patterns in ipl matches
#  the data can be used to predict the outcome of future matches
#  the data can be used to develop strategies for winning ipl matches